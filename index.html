<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Crypto Top 100 Volume Monitor</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'SF Pro Display', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 900px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(20px);
            border-radius: 24px;
            padding: 40px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.18);
        }
        
        h1 {
            text-align: center;
            margin-bottom: 30px;
            font-size: 2.5em;
            font-weight: 700;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
            background: linear-gradient(45deg, #ffd700, #ffed4e);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .setup-card {
            background: rgba(255, 255, 255, 0.15);
            border-radius: 16px;
            padding: 30px;
            margin-bottom: 30px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .form-group {
            margin-bottom: 25px;
        }
        
        label {
            display: block;
            margin-bottom: 10px;
            font-weight: 600;
            color: #f0f8ff;
            font-size: 1.1em;
        }
        
        input, select {
            width: 100%;
            padding: 16px 20px;
            border: none;
            border-radius: 12px;
            background: rgba(255, 255, 255, 0.9);
            color: #333;
            font-size: 16px;
            transition: all 0.3s ease;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }
        
        input:focus, select:focus {
            outline: none;
            background: white;
            box-shadow: 0 0 20px rgba(255, 255, 255, 0.4);
            transform: translateY(-2px);
        }
        
        .btn {
            background: linear-gradient(45deg, #ff6b6b, #ee5a24);
            color: white;
            border: none;
            padding: 16px 32px;
            border-radius: 50px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            margin: 10px 8px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.2);
        }
        
        .btn:hover:not(:disabled) {
            transform: translateY(-3px);
            box-shadow: 0 8px 30px rgba(0, 0, 0, 0.3);
        }
        
        .btn.secondary {
            background: linear-gradient(45deg, #74b9ff, #0984e3);
        }
        
        .btn:disabled {
            background: #666;
            cursor: not-allowed;
            opacity: 0.6;
        }
        
        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
            gap: 20px;
            margin: 30px 0;
        }
        
        .stat-card {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 16px;
            padding: 24px;
            text-align: center;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .stat-number {
            font-size: 2.2em;
            font-weight: bold;
            background: linear-gradient(45deg, #ffd700, #ffed4e);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            margin-bottom: 8px;
        }
        
        .stat-label {
            font-size: 0.9em;
            opacity: 0.9;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .log {
            background: rgba(0, 0, 0, 0.4);
            border-radius: 12px;
            padding: 25px;
            max-height: 350px;
            overflow-y: auto;
            font-family: 'SF Mono', 'Monaco', monospace;
            font-size: 14px;
            line-height: 1.6;
            margin-top: 20px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .log-entry {
            margin-bottom: 8px;
            padding: 8px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        .success { color: #2ecc71; }
        .error { color: #e74c3c; }
        .info { color: #3498db; }
        .warning { color: #f39c12; }
        
        .new-coin {
            background: rgba(46, 204, 113, 0.2);
            border-left: 4px solid #2ecc71;
            padding: 15px;
            border-radius: 8px;
            margin: 10px 0;
        }
        
        .pulse {
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0% { transform: scale(1); }
            50% { transform: scale(1.05); }
            100% { transform: scale(1); }
        }
        
        .method-selector {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            padding: 20px;
            margin-bottom: 25px;
        }
        
        .method-option {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 15px;
            margin: 10px 0;
            cursor: pointer;
            transition: all 0.3s ease;
            border: 2px solid transparent;
        }
        
        .method-option:hover {
            background: rgba(255, 255, 255, 0.15);
        }
        
        .method-option.selected {
            border-color: #ffd700;
            background: rgba(255, 215, 0, 0.1);
        }
        
        .setup-steps {
            background: rgba(255, 255, 255, 0.05);
            border-radius: 12px;
            padding: 20px;
            margin-top: 20px;
        }
        
        .step {
            margin: 15px 0;
            padding-left: 30px;
            position: relative;
        }
        
        .step::before {
            content: '‚úì';
            position: absolute;
            left: 0;
            color: #2ecc71;
            font-weight: bold;
        }
        
        @media (max-width: 768px) {
            .container { padding: 24px; }
            h1 { font-size: 2em; }
            .btn { width: 100%; margin: 8px 0; }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üöÄ Crypto Volume Monitor</h1>
        <p style="text-align: center; opacity: 0.9; margin-bottom: 30px;">
            Monitor top 100 cryptocurrencies by volume - get email alerts when new coins enter the list!
        </p>
        
        <div class="setup-card">
            <h2 style="margin-bottom: 25px;">üìß Choose Your Email Method</h2>
            
            <div class="method-selector">
                <div class="method-option selected" onclick="selectMethod('emailjs')">
                    <h3>üéØ EmailJS (Recommended - FREE)</h3>
                    <p>Easy setup, no passwords needed. 200 free emails/month.</p>
                </div>
                
                <div class="method-option" onclick="selectMethod('webhook')">
                    <h3>üîó IFTTT Webhook (FREE)</h3>
                    <p>Connect to any email service through automation.</p>
                </div>
                
                <div class="method-option" onclick="selectMethod('browser')">
                    <h3>üåê Browser Notification Only</h3>
                    <p>Just show alerts in browser, no email.</p>
                </div>
            </div>
            
            <div id="emailjs-setup" class="setup-steps">
                <h3>üìã EmailJS Setup (2 minutes):</h3>
                <div class="step">Sign up at <a href="https://emailjs.com" target="_blank" style="color: #ffd700;">emailjs.com</a></div>
                <div class="step">Create an email service (Gmail, Outlook, etc.)</div>
                <div class="step">Get your Public Key from EmailJS dashboard</div>
                <div class="step">Paste it below and you're ready!</div>
                
                <div class="form-group" style="margin-top: 20px;">
                    <label>EmailJS Public Key:</label>
                    <input type="text" id="emailjsKey" placeholder="your_public_key_here">
                </div>
                
                <div class="form-group">
                    <label>EmailJS Service ID:</label>
                    <input type="text" id="serviceId" placeholder="service_xxxxxxx">
                </div>
                
                <div class="form-group">
                    <label>EmailJS Template ID:</label>
                    <input type="text" id="templateId" placeholder="template_xxxxxxx">
                </div>
            </div>
            
            <div id="webhook-setup" class="setup-steps" style="display: none;">
                <h3>üìã IFTTT Webhook Setup:</h3>
                <div class="step">Go to <a href="https://ifttt.com" target="_blank" style="color: #ffd700;">ifttt.com</a></div>
                <div class="step">Create: "If Webhook, Then Send Email"</div>
                <div class="step">Get your Webhook URL</div>
                <div class="step">Paste it below</div>
                
                <div class="form-group" style="margin-top: 20px;">
                    <label>IFTTT Webhook URL:</label>
                    <input type="url" id="webhookUrl" placeholder="https://maker.ifttt.com/trigger/...">
                </div>
            </div>
            
            <div id="browser-setup" class="setup-steps" style="display: none;">
                <h3>üìã Browser-Only Setup:</h3>
                <p>No additional setup needed! You'll get notifications right in the browser.</p>
            </div>
            
            <div class="form-group">
                <label>üì® Your Email Address (for notifications):</label>
                <input type="email" id="email" placeholder="your.email@gmail.com">
            </div>
            
            <div class="form-group">
                <label>‚è∞ Daily Check Time:</label>
                <input type="time" id="notificationTime" value="17:00">
            </div>
            
            <div style="text-align: center; margin-top: 30px;">
                <button class="btn" onclick="startMonitoring()">üéØ Start Monitoring</button>
                <button class="btn secondary" onclick="stopMonitoring()">‚èπÔ∏è Stop</button>
                <button class="btn secondary" onclick="testCheck()">üß™ Test Now</button>
            </div>
        </div>
        
        <div class="stats">
            <div class="stat-card">
                <div class="stat-number" id="trackedCoins">0</div>
                <div class="stat-label">Tracked Coins</div>
            </div>
            <div class="stat-card">
                <div class="stat-number" id="newCoinsToday">0</div>
                <div class="stat-label">New Today</div>
            </div>
            <div class="stat-card">
                <div class="stat-number" id="statusIcon">üî¥</div>
                <div class="stat-label">Monitoring</div>
            </div>
            <div class="stat-card">
                <div class="stat-number" id="nextCheck">--:--</div>
                <div class="stat-label">Next Check</div>
            </div>
        </div>
        
        <div class="setup-card">
            <h3>üìä Activity Log</h3>
            <div class="log" id="log"></div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/@emailjs/browser@3/dist/email.min.js"></script>
    <script>
        class SimpleCryptoMonitor {
            constructor() {
                this.previousTop100 = new Set();
                this.isMonitoring = false;
                this.monitoringInterval = null;
                this.nextCheckTime = null;
                this.newCoinsToday = 0;
                this.lastCheckDate = null;
                this.currentMethod = 'emailjs';
                this.loadData();
                this.scheduleChecks();
            }
            
            loadData() {
                const saved = localStorage.getItem('cryptoMonitorData');
                if (saved) {
                    try {
                        const data = JSON.parse(saved);
                        this.previousTop100 = new Set(data.top100 || []);
                        this.newCoinsToday = data.newCoinsToday || 0;
                        this.lastCheckDate = data.lastCheckDate;
                        this.log("üìÅ Loaded previous tracking data", "info");
                    } catch (e) {
                        this.log("‚ùå Error loading data, starting fresh", "warning");
                    }
                }
                this.updateStats();
            }
            
            saveData() {
                const data = {
                    top100: Array.from(this.previousTop100),
                    newCoinsToday: this.newCoinsToday,
                    lastCheckDate: this.lastCheckDate,
                    timestamp: new Date().toISOString()
                };
                localStorage.setItem('cryptoMonitorData', JSON.stringify(data));
            }
            
            async fetchTop100() {
                const url = 'https://api.coingecko.com/api/v3/coins/markets?vs_currency=usd&order=volume_desc&per_page=100&page=1&sparkline=false&price_change_percentage=24h';
                
                try {
                    const response = await fetch(url);
                    if (!response.ok) throw new Error(`HTTP ${response.status}`);
                    return await response.json();
                } catch (error) {
                    this.log(`‚ùå API Error: ${error.message}`, "error");
                    return null;
                }
            }
            
            async checkForNewCoins() {
                this.log("üîç Checking for new coins in top 100...", "info");
                
                const currentData = await this.fetchTop100();
                if (!currentData) return { newCoins: [], hasChanges: false };
                
                const currentTop100 = new Set(currentData.map(coin => coin.id));
                const newCoins = currentData.filter(coin => !this.previousTop100.has(coin.id));
                
                const today = new Date().toDateString();
                if (this.lastCheckDate !== today) {
                    this.newCoinsToday = 0;
                    this.lastCheckDate = today;
                }
                
                if (newCoins.length > 0) {
                    this.newCoinsToday += newCoins.length;
                    this.previousTop100 = currentTop100;
                    this.saveData();
                    
                    newCoins.forEach(coin => {
                        const volume = this.formatVolume(coin.total_volume);
                        const price = coin.current_price < 1 ? 
                            `$${coin.current_price.toFixed(6)}` : 
                            `$${coin.current_price.toFixed(2)}`;
                        const change = coin.price_change_percentage_24h ? 
                            `${coin.price_change_percentage_24h.toFixed(2)}%` : 'N/A';
                        
                        this.log(
                            `üöÄ NEW COIN: ${coin.name} (${coin.symbol.toUpperCase()}) - Rank #${coin.market_cap_rank}<br>   üí∞ Price: ${price} (${change}) | üìä Volume: ${volume}`,
                            "new-coin"
                        );
                    });
                    
                    await this.sendNotification(newCoins);
                } else {
                    this.log("‚úÖ No new coins detected in top 100", "info");
                }
                
                this.updateStats();
                return { newCoins, hasChanges: newCoins.length > 0 };
            }
            
            formatVolume(volume) {
                if (volume >= 1e9) return `$${(volume/1e9).toFixed(2)}B`;
                if (volume >= 1e6) return `$${(volume/1e6).toFixed(2)}M`;
                return `$${volume.toLocaleString()}`;
            }
            
            async sendNotification(newCoins) {
                const email = document.getElementById('email').value;
                
                if (this.currentMethod === 'emailjs') {
                    await this.sendEmailJSNotification(newCoins, email);
                } else if (this.currentMethod === 'webhook') {
                    await this.sendWebhookNotification(newCoins, email);
                } else {
                    this.log("üì± Browser notification: Check the log above for new coins!", "info");
                }
            }
            
            async sendEmailJSNotification(newCoins, email) {
                const publicKey = document.getElementById('emailjsKey').value;
                const serviceId = document.getElementById('serviceId').value;
                const templateId = document.getElementById('templateId').value;
                
                if (!publicKey || !serviceId || !templateId || !email) {
                    this.log("‚ùå EmailJS not fully configured", "error");
                    return;
                }
                
                try {
                    const templateParams = {
                        to_email: email,
                        subject: `üöÄ ${newCoins.length} New Crypto(s) in Top 100!`,
                        message: newCoins.map(coin => 
                            `${coin.name} (${coin.symbol.toUpperCase()}) - $${coin.current_price} | Vol: ${this.formatVolume(coin.total_volume)}`
                        ).join('\n'),
                        coin_count: newCoins.length
                    };
                    
                    await emailjs.send(serviceId, templateId, templateParams, publicKey);
                    this.log(`üìß Email sent successfully via EmailJS to ${email}`, "success");
                } catch (error) {
                    this.log(`‚ùå EmailJS error: ${error.text || error.message}`, "error");
                }
            }
            
            async sendWebhookNotification(newCoins, email) {
                const webhookUrl = document.getElementById('webhookUrl').value;
                
                if (!webhookUrl) {
                    this.log("‚ùå Webhook URL not configured", "error");
                    return;
                }
                
                try {
                    const payload = {
                        value1: `${newCoins.length} new crypto(s) in top 100`,
                        value2: newCoins.map(coin => coin.name).join(', '),
                        value3: email
                    };
                    
                    await fetch(webhookUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify(payload)
                    });
                    
                    this.log(`üîó Webhook notification sent successfully`, "success");
                } catch (error) {
                    this.log(`‚ùå Webhook error: ${error.message}`, "error");
                }
            }
            
            scheduleChecks() {
                if (this.monitoringInterval) {
                    clearInterval(this.monitoringInterval);
                }
                
                this.monitoringInterval = setInterval(() => {
                    if (this.isMonitoring) {
                        this.checkScheduledTime();
                    }
                }, 60000);
            }
            
            checkScheduledTime() {
                const now = new Date();
                const targetTime = document.getElementById('notificationTime').value;
                const [hours, minutes] = targetTime.split(':').map(Number);
                
                if (now.getHours() === hours && now.getMinutes() === minutes) {
                    this.checkForNewCoins();
                }
                
                const nextCheck = new Date();
                nextCheck.setHours(hours, minutes, 0, 0);
                if (nextCheck <= now) {
                    nextCheck.setDate(nextCheck.getDate() + 1);
                }
                this.nextCheckTime = nextCheck;
                this.updateStats();
            }
            
            updateStats() {
                document.getElementById('trackedCoins').textContent = this.previousTop100.size;
                document.getElementById('newCoinsToday').textContent = this.newCoinsToday;
                document.getElementById('statusIcon').textContent = this.isMonitoring ? 'üü¢' : 'üî¥';
                
                if (this.nextCheckTime && this.isMonitoring) {
                    const timeStr = this.nextCheckTime.toLocaleTimeString('en-US', {
                        hour: '2-digit',
                        minute: '2-digit'
                    });
                    document.getElementById('nextCheck').textContent = timeStr;
                } else {
                    document.getElementById('nextCheck').textContent = '--:--';
                }
            }
            
            log(message, type = "info") {
                const logDiv = document.getElementById('log');
                const timestamp = new Date().toLocaleTimeString();
                const entry = document.createElement('div');
                entry.className = `log-entry ${type}`;
                entry.innerHTML = `<strong>[${timestamp}]</strong> ${message}`;
                logDiv.appendChild(entry);
                logDiv.scrollTop = logDiv.scrollHeight;
            }
        }
        
        const monitor = new SimpleCryptoMonitor();
        
        function selectMethod(method) {
            monitor.currentMethod = method;
            
            document.querySelectorAll('.method-option').forEach(el => el.classList.remove('selected'));
            event.target.closest('.method-option').classList.add('selected');
            
            document.getElementById('emailjs-setup').style.display = method === 'emailjs' ? 'block' : 'none';
            document.getElementById('webhook-setup').style.display = method === 'webhook' ? 'block' : 'none';
            document.getElementById('browser-setup').style.display = method === 'browser' ? 'block' : 'none';
            
            monitor.log(`üìß Selected method: ${method}`, "info");
        }
        
        function startMonitoring() {
            const email = document.getElementById('email').value;
            const time = document.getElementById('notificationTime').value;
            
            if (!email && monitor.currentMethod !== 'browser') {
                monitor.log("‚ùå Please enter your email address", "error");
                return;
            }
            
            if (monitor.currentMethod === 'emailjs') {
                const key = document.getElementById('emailjsKey').value;
                const service = document.getElementById('serviceId').value;
                const template = document.getElementById('templateId').value;
                
                if (!key || !service || !template) {
                    monitor.log("‚ùå Please fill in all EmailJS fields", "error");
                    return;
                }
                
                emailjs.init(key);
            }
            
            monitor.isMonitoring = true;
            monitor.log(`üéØ Started monitoring! Daily checks at ${time}`, "success");
            monitor.updateStats();
        }
        
        function stopMonitoring() {
            monitor.isMonitoring = false;
            monitor.log("‚èπÔ∏è Stopped monitoring", "info");
            monitor.updateStats();
        }
        
        function testCheck() {
            monitor.checkForNewCoins();
        }
        
        monitor.log("üöÄ Crypto Monitor loaded!", "success");
        monitor.log("üìã Choose your email method above and configure it", "info");
    </script>
</body>
</html>
